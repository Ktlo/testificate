# Библиотека для журналирования

## Введение

За свой небольшой опыт разработки я уже успел познакомиться с некоторыми библиотеками для журналирования, такими как: SLF4J (и его реализация logback-classic), интерфейс C# для Windows System Event Log, модуль Python logging и интерфейс ILogger в C#. Поэтому очевидным решением для выполнения данной работы было бы просто повторить то, что я уже видел. Но так не интересно. Я решил поэкспериментировать и попытаться привнести что-то новое (ну или хотя бы то, что не видел). Так как я сейчас активно использую Kotlin, то было бы здорово попробовать реализовать библиотеку журналирования, которая имела бы какие-то особые возможности в контексте этого языка.

Во время разработки приложений на Kotlin, которые используют корутины, я проникся идеей дерева задач (Job), которое формируется из корутин при правильном их применении. То-есть у нас есть главная корутина, которая начинается с функции main и далее может разделиться на несколько параллельных задач или даже объектов, которые наследуют или инкапсулируют CoroutineScope. Это дерево может дальше разделяться на другие задачи.

Есть некая идея, что структура такого дерево напрямую зависит от смысла приложения и его нужд. Если есть возможность сделать одну главную первую задачу, то можно, двигаясь по этому дереву точно сказать, какая часть программы, где находится и от чего была образована.

Подводя к итоговой идее, добавлю, что в библиотеке kotlinx-coroutines есть объект CoroutineName, который можно использовать для именования корутины. Можно попробовать использовать его для повторения структуры этого дерева в имени каждой новой задачи. Например, пусть главная задача (запущенная функцией main) называется «main», тогда задачи, образованные главной задачей, имеют имена «main/task1», «main/other-task» и подобные им. Таким образом будет выстроено дерево имён, образованное по аналогии с именами в файловом дереве.

## Домены

Так вот, пусть такие имена корутин и будут доменами журнала, по которым в итоге можно будет фильтровать сообщения. В данном примере я как раз и буду для этого использовать объект CoroutineName с текстовыми именами, но, по сути, ситуация может быть намного сложнее. Имеется смысл использовать не текст, а дерево любых объектов разных типов. Например, такое будет полезно, если домен привязан к какой-то сессии. Таким образом новый уровень в этом дереве будет объектом сессии, который каким-то образом может быть сериализован при выводе в файл.

## Уровень журналирования

Кроме доменов журнала пусть в моей библиотеке так же имеются уровни журналирования. По этим уровням будет ограничиваться вывод сообщений.

```kotlin
enum class Level {
    None, Fatal, Error, Warning, Info, Debug, Trace;
}
```

Среди этих уровней есть `Fatal`. По смыслу этот уровень означает, что приложения находится в неправильном состоянии и не может продолжить работу. Запомним это, так как тут имеет смысл предпринять дополнительные действия, а не просто вывести сообщение.

## Стратегия вывода сообщений

Введём специальный интерфейс, реализации которого будут заниматься выводом сообщений.

```kotlin
interface Output {

    fun write(level: Level, domain: String, message: Any?)

    fun throwable(level: Level, domain: String, throwable: Throwable, message: Any?) {
        write(level, domain, message.toString() + ": " + throwable.stackTraceToString())
    }

    fun throwable(level: Level, domain: String, throwable: Throwable) {
        throwable(level, domain, throwable, "error occurred")
    }
}
```

У этого интерфейса есть 3 метода. Один для вывода любых сообщение, второй для вывода исключения с комментарием, а третий для вывода исключения без комментария. Для вывода исключений отдельные методы существуют не просто так. Дело в том, что при выводе исключения хочется просмотреть стек вызовов. В зависимости от реализации стратегии вывода стек вызовов может быть представлен по-разному, но, кроме этого, само преобразование объекта `Throwable` в строку не приводит к получению текстового вида стека вызовов, поэтому требует от программиста дополнительных усилий по формированию текстового представления стека вызовов.

В таком виде интерфейса сообщения представлены любыми объектами, которые даже могут быть null. Это может быть полезно, так как реализация стратегии вывода может представить сообщения как-то иначе в зависимости от контекста. В данной работе не было цели сделать мультиплатформенную библиотеку логирования, но в качестве примера можно привести функцию `console.log` в JavaScript (Kotlin/JS). Эта функция как раз может отобразить любые объекты в логе.

Во всех функциях стратегии используются аргументы domain и level. Которые соответствуют домену журнала и уровню сообщения. Эта информация может быть также полезна при сохранении отдельных сообщений. По-хорошему этого недостаточно и для серьёзной библиотеки должно быть что-то вместо этих параметров, что позволило бы выделить больше контекста вокруг записываемого сообщения.

В качестве параметров, которые могут быть удобны для определения контекста сообщения может быть также удобен контекст корутин (там может быть объект, привязанный к транзакции, например) или уровень стека, в котором выполняется вызов метода, выводящего сообщение в самой программе (для извлечения имени файла и номера строки исходного текста программы, в котором выполнялся вызов методов объекта журналирования). Но так как это не суть, забудем о таких возможностях.

Стратегия вывода сообщений по смыслу будет использована разными объектами журналирования, каждый из которых будет передавать имя своего домена и уровень сообщения. Стратегия вывода при этом не должна заниматься фильтрацией сообщений по уровню, так как предполагается, что это уже было сделано объектом журналирования. Уровень нужен только для извлечения большего контекста выводимого сообщения.

## Конфигурация журнала

Сделаем способ изменения настроек для отдельных доменов журнала. Код для этого представлен в файле [**Configuration.kt**](modules/log/src/main/kotlin/ktlo/log/Configuration.kt). Здесь же я просто опишу, что будет представлять из себя файл конфигурации.

Каждому сконфигурированному домену будет соответствовать объект `Configuration`.

```kotlin
data class Configuration(
    val domain: String,
    val level: Level = Level.Info,
    val output: KClass<out Output>
)
```

Пусть конфигурационный файл называется «*log.yaml*» и находится в директории META-INF в class path, который доступен загрузчику классов, который загрузил класс Log данной библиотеки. По сути, это означает, что в стандартном fat jar приложении это будет сам загрузчик классов приложения. То-есть этот файл в итоге и будет находится в этом jar файле в директории META-INF.

Конфигурация представляет из себя дерево доменов с их параметрами. В качестве параметров может быть уровень журналирования и имя класса стратегии вывода (используется тот же загрузчик классов, что был использован для загрузки конфигурационного файла). Все поддомены последнего настроенного уровня будут иметь ту же конфигурацию, что и настроенный уровень. Вложенные домены наследуют настройки домена выше.

```yaml
echo-server: # Коренной домен журнала
  level: trace
  client:    # Домен, в котором размещены все поддомены клиентов
    level: info
    output: ktlo.log.outputs.ConsoleOutput
```

Такой способ конфигурации не полностью отражает идею дерева доменов, но об этом подробнее я напишу в конце.

## Разрушительный сбой

Вернёмся к уровню журналирования `Fatal`. Этот уровень означает, что программа находится в некорректном состоянии и не может продолжать работу. По смыслу вывод сообщений данного уровня должен обеспечивать остановку программы. Остановить программу можно вызвав функцию `exitProcess`. Такой подход не позволяет спасти данные или освободить какие-то ресурсы, которые не связаны с процессом напрямую. Хотелось бы иметь больше контроля над такими способами. В Kotlin есть более разумный способ осуществить завершение работы программы. Можно выбросить исключение, которое не будет поймано в других частях программы, если это не будет сделано намеренно.

Если руки растут откуда надо, то программист при ловле исключений будет фильтровать их только по ожидаемым типам ну или хотя бы по типу `Exception`. Кроме этого типа есть также `Error`, который по смыслу как раз и подходит. Создадим же свой тип ошибок, наследующий `Error`. Ошибки данного типа будут выброшены после записи сообщения уровня `Fatal`.

```kotlin
class FatalError : Error {
    constructor() : super()
    constructor(message: String?) : super(message)
    constructor(cause: Throwable?) : super(cause)
    constructor(message: String?, cause: Throwable?) : super(message, cause)
}
```

## Объект журналирования

Создадим тип, с которым будет взаимодействовать пользователь библиотеки. Этот тип будет проверять, можно ли ему выводить сообщение указанного уровня в текущем домене. Объекты этого типы будут инкапсулировать стратегию вывода, куда будут отправлять сообщения, имя домена для этого объекта журналирования, а также конфигурацию для последнего в этой ветви настроенного домена в конфигурационном файле (это не обязательно сам домен текущего объекта журналирования).

```kotlin
class Log(
    private val output: Output,
    public val domain: String,
    public val configuration: Configuration
) {
    /* ... */
}
```

Сделаем три основных метода для вывода сообщений в классе `Log`, которые по смыслу похожи на те три метода, что мы видели в стратегии вывода сообщений журнала.

```kotlin
inline fun write(level: Level, message: () -> Any?) {
   if (level <= this.level) {
      output.write(level, domain, message())
   }
}

inline fun throwable(level: Level, throwable: Throwable, message: () -> Any?) {
   if (level <= this.level) {
      output.throwable(level, domain, throwable, message())
   }
}

public fun throwable(level: Level, throwable: Throwable) {
   if (level <= this.level) {
      output.throwable(level, domain, throwable)
   }
}
```

Можно заметить, что имеются некоторые различия в сигнатуре этих методов, если сравнивать с интерфейсом стратегии вывода.

Первое, что бросается в глаза – это отсутствие имени домена объекта журналирования, что логично, так как он встроен в сам объект журналирования и использование этого объекта подразумевает какой-то конкретный домен.

Второе – параметр сообщения больше не представлен объектом неопределённого типа, а имеет вид функции, которая возвращает объект неопределённого типа. В этом месте я решил использовать другие возможности Kotlin, которые могут помочь сформировать выводимое сообщение в таком виде, в котором программист привык создавать любые объекты. Идея не нова, а спёрта из других проектов, таких как [kotlin-logging](https://www.kotlinresources.com/library/kotlin-logging/). Поэтому подробно останавливаться здесь не буду, но отмечу то, что в отличие от имеющихся реализаций мне хватило наглости также использовать ключевое слово inline, которое позволяет перенести байткод данной функции на то место, где она вызывает функцию `message`. Плюсом такого подхода является небольшой прирост производительности. При частом выводе в журнал это может быть полезно.

Эти методы не просто отправляют сообщение в стратегию вывода, но сперва проверяют, могут ли они отправить сообщение указанного в параметре `level` уровня. Если могут, то сообщение конструируется на месте и отправляется на вывод, если не могут, то оно даже не конструируется.

Использовать эти три метода напрямую не очень удобно. Использование лога должно быть максимально приятным, чтобы даже в голову не приходило использовать `println`, поэтому добавим для каждого типа уровня сообщений отдельный метод.

```kotlin
// Аналогично для остальных уровней

inline fun info(message: () -> Any?) {
   write(Level.Info, message)
}

inline fun info(throwable: Throwable, message: () -> Any?) {
   throwable(Level.Info, throwable, message)
}

fun info(throwable: Throwable) {
   throwable(Level.Info, throwable)
}
```

Методы для вывода сообщений уровня `Fatal` следует оформить по-другому. После вывода сообщения они должны выбросить ошибку `FatalError`, независимо от разрешённого уровня журналирования для текущего объекта журналирования. То-есть сообщение может быть не выведено в журнал, но ошибка всё равно должна произойти. В конструкторе `FatalError` есть параметр, в который можно передать сообщение, раскрывающее какие-то подробности об ошибке, туда можно передать текстовое представление сообщения, предназначенного для лога.

Такое поведение метода `Log::fatal` может сообщить нам о двух интересных деталях:
1. Этот метод не вернётся ни при каких условиях.
2. Сообщение будет сконструировано в любом случае, так как оно будет передано в конструктор `FatalError`, которое будет выброшено в любом случае. 
   
В Kotlin есть способы описания функций, которые не возвращаются. Такие функции должны в сигнатуре возвращать объект типа `Nothing`, который по смыслу наследует все объекты и реализует все интерфейсы, но объект данного типа невозможно получить.

Тип параметра конструктора сообщения следует заменить на само сообщение, но я решил оставить так для достижения некой общности между сигнатурами методов журналирования сообщений разных уровней. Правда также решил ввести дополнительный метод, который в параметры принимает само сообщение, чтобы не инлайнилось много кода.

```kotlin
@PublishedApi
internal fun fatal(message: Any?): Nothing {
   if (Level.Fatal <= level) {
      output.write(level, domain, message)
   }
   throw FatalError(message.toString())
}

public inline fun fatal(message: () -> Any?): Nothing {
   fatal(message())
}
```

## Получение объекта журналирования

Сам объект журналирования готов и его можно использовать, но всё ещё открыт вопрос: «Как его получить?». Для его получения сделаем объект-компаньон для класса Log. Пусть этот объект будет раздавать и создавать новые объекты Log.

Создадим в нём следующую функцию `Log::get`. Эта функция будет создавать объект журналирования для указанного домена в соответствии с загруженной кофигурацией.

```kotlin
public fun get(domain: String): Log {
   val configuration = confTree.get(domain)
   val output = outputs.getOrPut(configuration.output) {
      configuration.output.primaryConstructor!!.callBy(emptyMap())
   }
   return Log(output, domain, configuration)
}
```

Отлично, объект мы получить можем, но откуда брать домен? Здесь мы возвращаемся к изначальной идее дерева задач, привязанных к корутинам, которая была описана в самом начале.

Чтобы реализовать эту идею создадим локальную переменную для потока, которая будет хранить текущий объект журналирования. Предупреждаю возможные вопросы, о том, насколько безопасно использовать локальные для потока переменные в корутинах, которые могут скакать между потоками и скажу, что я этот момент учёл. Кажется, что логично было бы использовать контекст корутин, если домен будет соответствовать дереву задач. Это действительно так и он будет использован, но, к сожалению, если мы будем использовать только лишь контекст корутин, то получить журнал в непрерывных функциях будет невозможно.

```kotlin
@PublishedApi
internal val _current: ThreadLocal<Log> = ThreadLocal()

val current: Log get() = _current.get() ?: empty
```

Из этой переменной можно всегда получить журнал для текущего контекста дерева задач, но пока остаётся не ясно, как получить домен и что будет управлять значением этой переменной. Создадим сначала функцию, которая на время работы вложенной функции заменяет значение переменной `Log.Companion::current` на указанное.

```kotlin
inline fun <R> using(log: Log, block: () -> R): R {
   val previous = _current.get()
   try {
      _current.set(log)
      return block()
   } finally {
      if (previous == null) {
         _current.remove()
      } else {
         _current.set(previous)
      }
   }
}
```

Такая функция позволит менять значение переменной текущего объекта журналирования и при это контролирует, что при выходе из функции старое значение было возвращено на место. Таким образом можно менять значение переменной для одного потока. Всё ещё не ясно откуда брать домен.

Наконец можно реализовать систему объектов журналирования, которые привязаны логически к структуре самой программы, а именно к дереву задач и подпрограмм. Реализуем сначала создание объекта журналирования для подпрограммы. Подпрограмма работает в одном потоке и по смыслу не вызывает подзадач. Подпрограмма не корутина и поэтому мы не можем получить доступ к контексту корутин, чтобы получить имя корутины. Но оно и не нужно. Мы всё ещё можем получить текущий объект журналирования из `Log.Companion::current`, извлечь из него имя домена и добавить новый уровень, символизирующий данную подпрограмму. Реализуем это.

```kotlin
inline fun <R> subprogram(name: String, block: () -> R): R {
    val log = Log.current
    return Log.using(Log.get(log.domain + '/' + name), block)
}
```

В мире корутин всё немного иначе и сложнее. Задача – это не обязательно подпрограмма, она может работать параллельно с другими задачами. Также корутины могут перемещаться между потоками, что затрудняет использование `ThreadLocal` переменных. Вместе с тем у корутин есть аналог ThreadLocal переменных и это контекст корутин. Воспользуемся им, чтобы извлечь имя текущей корутины, добавим к этому имени указанный уровень домена и создадим новый контекст с новым именем, а также с объектом `TheardContextElement`. Этот тип будет управлять значением переменной `Log.Companion::current ` и контролировать, чтобы её значение было привязано к контексту корутины.

```kotlin
suspend fun <R> branch(
   name: String,
   context: CoroutineContext = EmptyCoroutineContext,
   block: suspend CoroutineScope.() -> R
): R {
   val coroutineName = coroutineContext[CoroutineName]
   val branchName = if (coroutineName == null) {
      name
   } else {
      coroutineName.name + '/' + name
   }
   val newContext = context + CoroutineName(branchName) +
           Log._current.asContextElement(Log.get(branchName))
   return withContext(newContext, block)
}
```

## Использование журнала

На этом этапе понятно, как следует использовать журнал и именовать задачи и подпрограммы (если не понятно, то есть пример), но остаётся небольшая проблема. Если попытаться воспользоваться журналом, то выйдет следующее:

```kotlin
suspend fun main() = branch("root") {
   Log.current.info { "Hello there" }
}

```

Проблема в том, что это всё ещё не так просто, как `println`. Слишком длинно. Это разрешимая ситуация. Нам только нужно определить дополнительные функции для всех уровней сообщений журнала, которые сами будут получать текущий журнал. Вот только где их определить? Здесь есть два решения:
1. Определим их как обычные функции в текущем пакете. Очень хороший подход, так как их использование будет настолько же удобно, как вызов println, но с двумя оговорочками. Во-первых, каждую отдельную функцию следует заимпортить или заимпортить разом весь пакет библиотеки журналирования. Во-вторых, функция `error` для журналирования сообщений уровня `Error` по имени совпадает с функцией `kotlin.error`. Их сигнатуры всё ещё различимы, но путаницу какую-то это принести может.
2. Определим в объекте-компаньоне класса `Log` все функции для вывода сообщений текущего журнала. В итоге в программе потребуется вызвать функции такие как `Log.info { message }`. Этот вариант выглядит немного сложнее `println`, но у него отсутствуют проблемы предыдущего варианта. Кроме того, в этом месте раскрывается, почему имя класса не `Logger`, а `Log` 😊.

## Некорректное состояние

У нас уже есть функция, которая выводит в журнал сообщения о некорректном состоянии программы и выбрасывает ошибку `FatalError`. Понятно, что перед выбросом этой ошибки состояние где-то проверяется на эту самую корректность. В Kotlin для случаев проверки корректности аргументов или состояния существует набор функций `assert`, `check` и `require`. Имеет смысл по аналогии с ними реализовать и свою функцию, которая будет работать аналогично, но при этом регистрируя некорректное состояние в журнале.

```kotlin
inline fun validate(value: Boolean, message: () -> Any?) {
   contract {
      // Без контракта такие функции даже вредны
      callsInPlace(message, InvocationKind.AT_MOST_ONCE)
      returns() implies value
   }
   if (!value) {
      Log.fatal(message)
   }
}
```

## Пример программы

Напишем простой TCP эхо сервер. Код эхо сервера находится в каталоге [**module/echo-server**](module/echo-server) данного репозитория. По коду раскиданы комментарии с некоторыми интересными случаями использования библиотеки журналирования. Я только остановлюсь на одной проблеме, которую я до сих пор игнорировал.

Не весь код программы напоминает дерево задач. Иногда ветви этого дерева смыкаются в некоторых объектах-контроллерах или объектах-менеджерах. В программе представлен максимально искусственный пример такого менеджера.

Хочу также отметить, что используемая система конфигурирования доменов не полностью отражает суть подхода. Кроме менеджера, в который можно прийти из разных доменов, существуют сессии, которые могут ходить в разные домены. Для обозначения идентификатора сессии в поддомене использовался префикс «#», а для обозначения менеджера, использовался префикс «@».

## Вывод

Насколько я знаю, в Kotlin Multiplatform всё ещё актуальна проблема общего интерфейса для журналирования, аналогичному SLF4J в Java. Я попытался отойти от текущих идей журналирования и представить что-то, что имело бы бОльший смысл для Kotlin. Было бы здорово увидеть нечто подобное в библиотеке, которая когда-нибудь появится.
